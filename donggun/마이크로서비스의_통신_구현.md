# 마이크로서비스의 통신 구현

## 🗺️ 이상적인 기술을 찾아서

마이크로서비스 아키텍처에서 서비스 간 통신은 시스템의 성능, 확장성, 유지보수성에 큰 영향을 미칩니다. 따라서 통신 기술을 선택할 때는 신중한 고려가 필요합니다.

### 주요 통신 기술 옵션

- SOAP (Simple Object Access Protocol)
- XML-RPC (XML Remote Procedure Call)
- REST (Representational State Transfer)
- gRPC (Google Remote Procedure Call)

### 기술 선택 시 고려사항

항상 새로운 선택지가 등장하기 때문에 특정 기술을 논의하기 전에 선택한 기술에서 무엇을 원하는지 고민을 해야 합니다.

1. **하위 호환성**

   - API 버전 관리 용이성
   - 기존 클라이언트 지원 유지
   - 점진적 업그레이드 가능성

2. **명시적 인터페이스**

   - 명확한 계약 정의
   - 문서화 용이성
   - 타입 안정성

3. **기술 중립성**

   - 특정 플랫폼/언어 독립성
   - 다양한 클라이언트 지원
   - 향후 기술 변경 유연성

4. **단순성**

   - 사용하기 쉬운 API
   - 직관적인 인터페이스
   - 낮은 학습 곡선

5. **캡슐화**
   - 내부 구현 세부사항 은닉
   - 서비스 독립성 유지
   - 변경 영향도 최소화

## 🧐 기술 선택

다양한 기술 선택지 중에서 가장 대중적이고 흥미로운 선택지들에 대해 알아보겠습니다.

### 원격 프로시저 호출 (RPC)

RPC는 원격 프로세스의 메서드를 로컬처럼 호출하는 방식으로, SOAP와 gRPC가 대표적입니다.

**SOAP**
보안과 신뢰성이 중요한 금융 시스템 등에 유리합니다.

    - 복잡한 구현과 무거운 메시지 형식
    - XML 기반의 메시지 프로토콜
    - 풍부한 표준 지원
    - 엄격한 계약 정의

**gRPC**
낮은 대기 시간과 고속 처리가 요구되는 서비스에 적합합니다.

    - Protocol Buffers 사용
    - 높은 성능과 낮은 지연시간
    - 양방향 스트리밍 지원
    - 강력한 타입 시스템

### REST

REST는 URL을 통한 리소스 접근과 HTTP 메서드를 활용한 CRUD 연산으로 마이크로서비스를 설계하는 데 널리 사용됩니다. JSON 포맷으로 직렬화하며, 클라이언트와 서버의 결합도가 낮아 유연하게 확장할 수 있습니다.

- 리소스 중심 아키텍처
- 표준 HTTP 메소드 사용
- 상태를 저장하지 않음
- 캐시 가능성
- 계층화된 시스템

### GraphQL

GraphQL은 소비자가 원하는 데이터를 직접 쿼리할 수 있어, 여러 마이크로서비스에서 데이터를 집계하고 선택적으로 전달하는 데 유리합니다.

- 유연한 데이터 요청
- 단일 엔드포인트
- 강력한 타입 시스템
- 실시간 구독 기능

### 메시지 브로커

RabbitMQ나 Kafka와 같은 메시지 브로커를 통해 비동기 메시징을 구현할 수 있으며, 마이크로서비스 간에 이벤트 기반 아키텍처를 구성할 때 활용됩니다.

- 메시지 큐잉
- 발행/구독 패턴
- 메시지 지속성
- 전달 보장
- 장애 복구

## 🔤 직렬화 포맷

데이터 직렬화는 전송 속도와 효율성에 큰 영향을 미칩니다. 상황에 따라 텍스트 포맷이나 바이너리 포맷을 선택할 수 있습니다.

### 텍스트 포맷

**JSON**
사람과 기계 모두 쉽게 이해할 수 있는 직렬화 포맷으로 REST API와 자주 함께 사용됩니다.

    - 읽기 쉽고 디버깅 용이
    - 널리 지원되는 표준
    - 상대적으로 큰 메시지 크기

**XML**
스키마 기반 검증이 필요한 경우 활용되며, SOAP 프로토콜에서 주로 사용됩니다.

    - 풍부한 메타데이터
    - 복잡한 데이터 구조 표현
    - 처리 오버헤드 높음

### 바이너리 포맷

**Protocol Buffers**
gRPC와 함께 사용되는 구글의 직렬화 포맷으로, XML이나 JSON보다 효율적입니다.

    - 작은 메시지 크기
    - 빠른 직렬화/역직렬화
    - 강력한 스키마 지원

**Avro**
스키마를 포함하여 데이터 구조를 정의하는 포맷으로, 데이터 압축 효율이 높아 Kafka 등에서 활용됩니다.

    - 동적 스키마 지원
    - 효율적인 직렬화
    - 스키마 진화 용이

## 📑 스키마

스키마는 서비스 간 통신에서 데이터의 구조와 형식을 정의하는 계약입니다. 마이크로서비스 환경에서 스키마는 서비스 간 안정적인 통신을 보장하고 변경 관리를 용이하게 합니다.

### 스키마의 필요성

1. **통신 안정성**

- 데이터 구조의 일관성 보장
- 타입 안전성 제공
- 버전 관리 용이성

2. **문서화**

- API 계약의 명확한 정의
- 자동화된 문서 생성
- 팀 간 커뮤니케이션 향상

3. **개발 생산성**

- 코드 생성 자동화
- 테스트 용이성
- 빠른 통합 및 디버깅

### 구조적 계약 위반 vs 의미적 계약 위반

**구조적 계약 위반**
필드의 타입이 변경되거나 필수 필드가 누락될 때 발생하는 문제로, 스키마 검증 단계에서 쉽게 발견할 수 있습니다.

    - 즉각적인 오류 발생
    - 쉽게 감지 가능
    - 자동화된 검증 가능

**의미적 계약 위반**
데이터 구조는 맞지만 데이터 값이 예상과 다를 때 발생합니다. 예를 들어, 주문 상태가 잘못된 상태 코드로 표시될 경우 구조적으로는 문제가 없지만 의미적으로는 오류가 생깁니다. 이러한 의미적 오류는 자동 검증이 어려우므로 추가적인 테스트와 문서화가 필요합니다.

    - 감지하기 어려움
    - 비즈니스 로직 오류 유발
    - 런타임에 문제 발생

### 명시적 스키마의 중요성

명시적 스키마를 사용하면 데이터 형식을 강제할 수 있으며, 버전 관리를 통해 데이터 형식을 유연하게 변경할 수 있습니다.

1. **계약 정의**

- 명확한 데이터 구조 정의
- 필드의 타입과 제약조건 명시
- 필수/선택 필드 구분

2. **버전 관리**

- 하위 호환성 보장
- 점진적 변경 지원
- 마이그레이션 경로 제공

3. **검증 자동화**

- 컴파일 타임 검증
- 런타임 유효성 검사
- 테스트 자동화

## 📚 참고 자료

- [마이크로서비스 아키텍처 구축 (전면 개정판)](https://product.kyobobook.co.kr/detail/S000202596905)
