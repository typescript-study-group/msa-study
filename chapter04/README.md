## 프로세스 간 호출 (Inter-Process) vs 프로세스 내 호출 (In-Process Call)

## 성능 측면

### 네트워크 사용과 패킷

- **프로세스 내 호출**:
    - **메모리 내 호출**: 동일 프로세스 내에서 함수나 메서드를 직접 호출하므로 네트워크 사용이 없음.
    - **낮은 지연 시간**: 메모리 접근 속도가 네트워크 접근 속도보다 훨씬 빠르기 때문에 호출 응답 시간이 짧음.
    - **오버헤드 최소화**: 함수 호출 스택 관리 외에는 추가적인 오버헤드가 거의 없음.
    - **캐시 효율성**: 동일 프로세스 내에서 데이터가 캐시에 존재할 가능성이 높아 성능 향상에 기여.
- **프로세스 간 호출**:
    - **네트워크 의존성**: 프로세스가 다른 머신이나 동일 머신의 다른 프로세스에서 실행될 경우, 네트워크를 통해 데이터를 주고받아야 함.
    - **패킷 오버헤드**: 데이터가 네트워크 패킷으로 분할되고 전송되며, 패킷 헤더와 전송 지연으로 인한 추가적인 오버헤드 발생.
    - **지연 시간 증가**: 네트워크 지연(latency)으로 인해 호출 응답 시간이 길어질 수 있음.
    - **대역폭 사용**: 네트워크 대역폭을 소모하여 다른 네트워크 트래픽에 영향을 미칠 수 있음.

## 직렬화

- **프로세스 간 호출**:
    - **데이터 변환 필요**: 데이터를 네트워크를 통해 전송하기 위해 직렬화(Serialize)하고, 수신 측에서 역직렬화(Deserialize)해야 함.
    - **추가 처리 시간**: 직렬화 및 역직렬화 과정에서 CPU 자원이 소모되고, 처리 시간이 증가함.
    - **데이터 형식 호환성**: 다양한 언어와 플랫폼 간의 데이터 형식 호환성을 유지하기 위해 표준화된 직렬화 포맷(예: JSON, Protocol Buffers)을 사용해야 함.
- **프로세스 내 호출**:
    - **직렬화 불필요**: 함수 호출 시 메모리 내에서 직접 데이터가 전달되므로 직렬화 과정이 필요 없음.
    - **빠른 데이터 전달**: 데이터가 메모리 주소를 통해 직접 전달되어 처리 속도가 매우 빠름.
    - **데이터 구조 일관성**: 동일한 프로세스 내에서 동일한 데이터 구조를 사용하므로 데이터 형식 호환성 문제가 없음.

## 인터페이스 변경

### 프로세스 내 호출: 함께 패키징

- **단일 배포 단위**: 모든 모듈이 하나의 패키지나 애플리케이션으로 배포되므로 인터페이스 변경 시 전체 애플리케이션을 재배포해야 함.
- **종속성 관리**: 모듈 간의 종속성이 강해져 개별 모듈의 독립적인 업데이트가 어려움.
- **결합도 증가**: 인터페이스 변경이 다른 모듈에 직접적인 영향을 미쳐 결합도가 높아짐.
- **테스트 용이성**: 단일 프로세스 내에서 통합 테스트가 상대적으로 용이함.

### 프로세스 간 호출: 개별 배포

- **락스텝 배포 (Lockstep Deployment)**:
    - **동기화된 배포**: 여러 프로세스가 동시에 업데이트되어 일관된 상태를 유지.
    - **배포 복잡성**: 여러 서비스의 동시 배포가 필요하여 배포 과정이 복잡해질 수 있음.
- **독립적인 배포**: 각 프로세스가 독립적인 배포 단위로 관리되어, 인터페이스 변경 시 해당 프로세스만 재배포 가능.
    - **유연성 향상**: 개별 서비스의 업데이트와 확장이 용이해져 시스템의 유연성이 증가함.
    - **버전 관리**: 각 프로세스가 독립적인 버전 관리를 가능하게 하여 점진적인 업데이트가 가능함.

## 에러처리

### 프로세스 내 호출: 결정적 (Deterministic) 특성

- **예측 가능성**: 함수 호출의 결과가 예측 가능하며, 동일한 입력에 대해 항상 동일한 출력을 보장함.
- **즉각적인 에러 처리**: 호출 실패 시 동일 프로세스 내에서 예외를 즉시 처리할 수 있어 에러 복구가 용이함.
- **트랜잭션 관리**: 동일 프로세스 내에서 트랜잭션 관리가 가능하여 일관된 상태 유지가 용이함.
- **디버깅 용이성**: 동일 프로세스 내에서 에러 발생 지점을 쉽게 추적하고 디버깅할 수 있음.

### 프로세스 간 호출

앤드류 탄넨바움, 마텐 스틴의 저서 “Distributed Systems(2023)”에서 프로세스 간 통신에서 나타나는 다섯가지 유형의 실패 모드

- **충돌 실패 (Crash Failure)**:
    - 서버가 중단될 때까지 모든 것이 정상적으로 동작하다가, 서버가 크래시되는 경우.
    - 해결 방법: 서버 재부팅.
- **누락 실패 (Omission Failure)**:
    - 메시지가 전송되었으나 응답을 받지 못하는 경우.
    - 해결 방법: 재전송 메커니즘 도입.
- **타이밍 실패 (Timing Failure)**:
    - 특정 작업이 너무 늦게 발생하거나, 예상보다 일찍 발생하는 경우.
    - 해결 방법: 타임아웃 설정 및 시간 동기화.
- **응답 실패 (Response Failure)**:
    - 응답은 받았으나, 응답 내용이 잘못된 경우.
    - 해결 방법: 응답 검증 및 오류 처리 로직 구현.
- **임의 실패 (Arbitrary Failure)**:
    - 비잔티움 실패(Byzantine Failure)라고도 하며,
    - 해결 방법: 견고한 오류 검증 및 복구 메커니즘 구축.

## 블로킹 방식

### 동기식 블로킹

- 설명
    - **대기 방식**: 호출자가 호출한 작업이 완료될 때까지 호출 지점에서 대기(block)하는 방식.
    - **호출 순서 유지**: 요청 순서대로 작업이 처리되며, 각 호출이 순차적으로 이루어짐.
    - **흐름 제어**: 호출자의 작업 흐름이 차단되어 다음 작업으로 진행하지 못함.
- 장점
    - **단순성**: 구현이 간단하고, 코드 흐름이 직관적이며 이해하기 쉬움.
    - **예측 가능성**: 호출 순서와 응답 시간이 예측 가능하여 디버깅이 용이함.
    - **동기화 용이**: 데이터 일관성 유지가 상대적으로 쉬움.
- 단점
    - **자원 비효율성**: 호출 대기 동안 호출 스레드가 블록되어 자원이 비효율적으로 사용됨.
    - **확장성 한계**: 동시 처리 능력이 제한되어 고부하 상황에서 성능 저하 발생 가능.
    - **응답 지연 영향**: 한 호출의 지연이 전체 시스템의 응답 속도에 직접적인 영향을 미침.
- 적용 대상
    - **짧은 응답 시간**: 작업이 빠르게 완료되어 호출자가 짧은 시간 내에 응답을 받을 수 있는 경우.
    - **단순한 요청-응답 패턴**: 복잡한 비동기 처리가 필요 없는 간단한 통신 패턴.
    - **낮은 동시성 요구**: 동시 요청이 많지 않아 블로킹으로 인한 자원 낭비가 크지 않은 경우.

### 비동기식 논블로킹

- 설명
    - **비대기 방식**: 호출자가 작업 완료를 기다리지 않고 즉시 다음 작업을 계속 수행하는 방식.
    - **콜백 및 프라미스**: 작업 완료 시 호출자에게 알리기 위해 콜백 함수, 프로미스(Promise), 이벤트 등을 사용.
    - **병렬 처리**: 여러 작업을 동시에 처리할 수 있어 높은 처리량을 달성 가능.
- 장점
    - **자원 효율성**: 호출자가 대기하지 않고 다른 작업을 수행할 수 있어 자원 사용 효율이 높음.
    - **높은 처리량**: 동시에 여러 작업을 처리할 수 있어 시스템의 전체 처리 능력이 향상됨.
    - **응답 지연 완화**: 특정 작업의 지연이 다른 작업에 영향을 미치지 않아 시스템의 응답성이 유지됨.
- 단점
    - **복잡한 구현**: 비동기 흐름을 관리하기 위한 추가 로직이 필요하여 코드가 복잡해짐.
    - **디버깅 어려움**: 비동기 호출로 인해 에러 발생 지점을 추적하고 디버깅하기 어려움.
    - **상태 관리**: 비동기 작업 간의 상태 관리가 복잡해질 수 있음.
- 적용 대상
    - **긴 응답 시간 작업**: 네트워크 호출, 파일 I/O 등 시간이 오래 걸리는 작업.
    - **고성능 및 확장성 요구**: 대규모 트래픽을 처리해야 하는 시스템.
    - **이벤트 기반 시스템**: 이벤트 처리나 실시간 데이터 스트리밍이 필요한 애플리케이션.

## 통신 방식

### 1. 공통 데이터를 통한 통신 (데이터레이크, 데이터 웨어하우스)

- 생산자와 소비자
    - **생산자 (Producer)**:
        - 데이터를 생성하여 데이터 저장소(데이터레이크, 데이터 웨어하우스)에 기록.
        - 예: 로그 생성기, 센서 데이터 수집기.
    - **소비자 (Consumer)**:
        - 저장소에 기록된 데이터를 읽어 분석, 처리 또는 시각화.
        - 예: 데이터 분석 도구, 보고서 생성기.
- 장점
    - **느슨한 결합**: 생산자와 소비자가 직접적으로 통신하지 않고 공통 데이터 저장소를 사용하여 느슨하게 결합됨.
    - **확장성**: 대용량 데이터를 저장하고 처리할 수 있어 빅데이터 환경에 적합.
    - **데이터 보존**: 데이터를 중앙 저장소에 보관하여 다양한 용도로 재사용 가능.
- 단점
    - **실시간 처리 어려움**: 데이터가 저장소에 기록된 후 소비자가 이를 처리하므로 실시간성 확보가 어려움.
    - **데이터 일관성 관리**: 여러 소비자가 동시에 데이터를 읽고 처리할 경우 일관성 유지가 복잡해질 수 있음.
    - **복잡한 데이터 파이프라인**: 데이터 추출, 변환, 로드(ETL) 과정이 필요하여 관리가 복잡함.
- 적용 대상
    - **빅데이터 분석**: 대규모 데이터셋을 분석하고 인사이트를 도출하는 용도.
    - **데이터 집약적인 애플리케이션**: 금융, 헬스케어 등 데이터 기반 의사결정이 중요한 분야.
    - **배치 처리 시스템**: 주기적으로 대량의 데이터를 처리하는 시스템.

### 2. 요청 및 응답 통신

- 동기식 방식
    - **동작 방식**: 클라이언트가 서버에 요청을 보내고, 서버가 응답을 반환할 때까지 클라이언트가 대기.
    - **대표적인 예**: RESTful API, gRPC.
    - **특징**:
        - 간단한 요청-응답 패턴.
        - 호출 순서가 일관되며, 응답을 기다리기 때문에 상태 관리가 용이.
    - 적용 대상
        - **실시간 응답이 필요한 서비스**: 사용자 로그인, 데이터 조회, 결제 처리 등 즉각적인 피드백이 요구되는 기능.
        - **단순한 요청-응답 패턴**: CRUD(Create, Read, Update, Delete) 작업과 같이 명확한 요청과 응답이 있는 작업.
        - **상태 관리가 중요한 애플리케이션**: 세션 관리나 트랜잭션 처리 등 상태 일관성이 필요한 경우.
- 비동기식 방식 (큐 - 메시지 브로커)
    - **동작 방식**: 클라이언트가 요청을 메시지 큐에 보내고, 서버는 큐에서 메시지를 읽어 처리. 응답은 별도로 전달.
    - **대표적인 예**: RabbitMQ, Kafka.
    - **특징**:
        - 요청과 응답이 분리되어 비동기적으로 처리.
        - 높은 확장성과 유연성을 제공하며, 메시지 브로커를 통해 안정적인 메시지 전달 가능.
    - 적용 대상
        - **높은 처리량과 확장성이 필요한 시스템**: 로그 수집, 이벤트 스트리밍, 대용량 데이터 처리 등.
        - **시간이 많이 소요되는 작업**: 이미지 처리, 비디오 인코딩, 데이터 분석 등 비동기적으로 처리해도 무방한 작업.
        - **분산 시스템**: 마이크로서비스 아키텍처에서 서비스 간의 느슨한 결합과 안정적인 메시지 전달이 필요한 경우.
        - **신뢰성이 중요한 작업**: 메시지의 손실 없이 안정적으로 전달해야 하는 금융 거래 처리, 주문 처리 시스템 등.

### 이벤트 기반 통신

- 토픽
    - **개념**: 이벤트를 특정 주제(토픽)별로 분류하여 발행(Publish)하고 구독(Subscribe)하는 모델.
    - **동작 방식**: 이벤트 생산자가 특정 토픽에 이벤트를 발행하면, 해당 토픽을 구독한 소비자에게 이벤트가 전달됨.
- **장점**:
    - 특정 주제에 관심 있는 소비자만 이벤트를 수신하여 효율적인 메시지 전달.
    - 이벤트 자체에 충분한 데이터를 포함하여 느슨한 결합과 시스템 확장성 향상.
- **단점:**
    - **복잡성 증가**: 이벤트 기반 시스템은 구성 요소 간의 관계가 명시적으로 드러나지 않아 시스템의 전체적인 동작을 이해하기 어려움
    - **일관성 관리의 어려움**: 이벤트 순서가 보장되지 않거나, 이벤트 처리 실패 시 재처리 로직 구현, 데이터 중복 문제 등
- 이벤트 자체에 충분한 데이터를 넣어야 하는 이유 (느슨한 결합)
    - **독립성 유지**: 이벤트에 필요한 모든 정보를 포함하여 이벤트 수신자가 추가적인 데이터를 요청하지 않고도 처리할 수 있도록 함.
    - **느슨한 결합과 확장성 향상**: 새로운 소비자가 이벤트를 수신할 때 추가적인 의존성이 없어서 시스템 확장이 용이함. (단, 이벤트 크기에 주의)
- 적용 대상
    - 이벤트정보를 브로드캐스트하길 원하는 상황
    - 다른일을 지시하기보다는, 다운스트림 마이크로서비스가 스스로 일을 하게 하는것
    - 실시간 데이터 스트리밍: 실시간 로그 수집, 사용자 활동 추적 등 빠른 데이터 처리와 전달이 필요한 경우.
    - 알림 시스템: 사용자에게 실시간 알림을 제공하는 시스템, 예: 채팅 애플리케이션, 실시간 모니터링 시스템.

## 결론

복잡성을 조심하라… 비동기 작업은 재밌긴한데 복잡성이 수반된다.
